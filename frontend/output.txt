import { BrowserRouter as Router, Routes, Route, Navigate } from "react-router-dom";
import Register from "@/components/auth/Register";
import Login from "@/components/auth/Login";
import QuadrantContainer from "@/components/quadrants/QuadrantContainer";
import { useSelector } from "react-redux";
import { RootState } from "@/redux/store";
import PrivateRoute from "@/components/PrivateRoute";

function App() {
  const auth = useSelector((state: RootState) => state.auth);

  return (
    <Router>
      <div className="min-h-screen bg-gray-800 text-white flex flex-col items-center justify-center w-full">
        <Routes>
          <Route
            path="/"
            element={auth.token ? <Navigate to="/tasks" /> : <Navigate to="/login" />}
          />
          <Route path="/register" element={<Register />} />
          <Route path="/login" element={<Login />} />
          <Route
            path="/tasks"
            element={
              <PrivateRoute>
                <QuadrantContainer />
              </PrivateRoute>
            }
          />
        </Routes>
      </div>
    </Router>
  );
}

export default App;
import { StrictMode } from "react";
import { createRoot } from "react-dom/client"
import { Provider } from "react-redux";
import { store } from "./redux/store";
import App from "./App";
import './tailwind.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </StrictMode>,
)
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import tailwindcss from 'tailwindcss'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  css: {
    postcss: {
      plugins: [tailwindcss]
    }
  },
  server: {
    host: true,
    port: 5173
  },
  resolve: {
    alias: {
      '@': '/src',
    }
  }
})
/// <reference types="vite/client" />
import { configureStore } from "@reduxjs/toolkit";
import { useDispatch } from "react-redux";
import createSagaMiddleware from "redux-saga";
import taskReducer from "./slices/taskSlice";
import authReducer from "./slices/authSlice";
import rootSaga from "./sagas";

const sagaMiddleware = createSagaMiddleware();

export const store = configureStore({
  reducer: {
    tasks: taskReducer,
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({ thunk: false }).concat(sagaMiddleware),
});

sagaMiddleware.run(rootSaga);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export const useAppDispatch = () => useDispatch<AppDispatch>();

export interface Task {
  id: string;
  quadrantId: string;
  title: string;
  description?: string;
  completed: boolean;
}
// src/redux/sagas/index.ts
import { all } from "redux-saga/effects";
import authSagas from "./authSaga";
import taskSagas from "./taskSagas";

export default function* rootSaga() {
  yield all([
    authSagas(),
    taskSagas(),
  ]);
}
import { takeLatest, call, put, all, fork } from "redux-saga/effects";
import axios, { AxiosResponse } from "axios";
import {
  registerRequest,
  registerSuccess,
  registerFailure,
  loginRequest,
  loginSuccess,
  loginFailure,
} from "../slices/authSlice";
import { SagaIterator } from "redux-saga";
import { PayloadAction } from "@reduxjs/toolkit";

const API_URL = "http://localhost:4000";

interface AuthResponse {
  token: string;
  username: string;
}

const registerApi = (uniqueID: string): Promise<AxiosResponse<AuthResponse>> =>
  axios.post<AuthResponse>(`${API_URL}/auth/register`, { uniqueID });

const loginApi = (uniqueID: string): Promise<AxiosResponse<AuthResponse>> =>
  axios.post<AuthResponse>(`${API_URL}/auth/login`, { uniqueID });

function* handleRegister(action: PayloadAction<string>): SagaIterator {
  try {
    const uniqueID: string = action.payload;
    const response: AxiosResponse<AuthResponse> = yield call(registerApi, uniqueID);
    const { token, username } = response.data;

    console.log("usernmae", username);
    console.log("token", token);
    console.log("response", response);

    if (!token || !username) {
      throw new Error("Invalid response from server");
    }

    localStorage.setItem("token", token);
    localStorage.setItem("username", username);

    yield put(registerSuccess({ token, username }));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Registration failed";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Registration failed";
    }

    yield put(registerFailure(errorMessage));
  }
}

function* handleLogin(action: PayloadAction<string>): SagaIterator {
  try {
    const uniqueID: string = action.payload;
    const response: AxiosResponse<{ token: string; username: string }> = yield call(loginApi, uniqueID);
    const { token, username } = response.data;

    if (!token || !username) {
      throw new Error("Invalid response from server");
    }

    localStorage.setItem("token", token);
    localStorage.setItem("username", username);

    yield put(loginSuccess({ token, username }));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Login failed";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Login failed";
    }

    yield put(loginFailure(errorMessage));
  }
}

function* watchRegister() {
  yield takeLatest(registerRequest.type, handleRegister);
}

function* watchLogin() {
  yield takeLatest(loginRequest.type, handleLogin);
}

export default function* authSagas() {
  yield all([fork(watchRegister), fork(watchLogin)]);
}
// src/redux/sagas/taskSagas.ts
import { takeLatest, call, put, select, all, fork } from "redux-saga/effects";
import axios, { AxiosResponse } from "axios";
import {
  fetchTasksRequest,
  fetchTasksSuccess,
  fetchTasksFailure,
  createTaskRequest,
  createTaskSuccess,
  createTaskFailure,
  updateTaskRequest,
  updateTaskSuccess,
  updateTaskFailure,
  deleteTaskRequest,
  deleteTaskSuccess,
  deleteTaskFailure,
} from "../slices/taskSlice";
import { RootState } from "../store";
import { SagaIterator } from "redux-saga";
import { PayloadAction } from "@reduxjs/toolkit";

const API_URL = "http://localhost:4000";

interface TaskResponse {
  id: string;
  title: string;
  completed: boolean;
  quadrantId: string;
}

const fetchTasksApi = (token: string): Promise<AxiosResponse<TaskResponse[]>> =>
  axios.get<TaskResponse[]>(`${API_URL}/tasks`, {
    headers: { Authorization: `Bearer ${token}` },
  });

const createTaskApi = (
  task: { title: string; quadrantId: string },
  token: string
): Promise<AxiosResponse<TaskResponse>> =>
  axios.post<TaskResponse>(`${API_URL}/tasks`, task, {
    headers: { Authorization: `Bearer ${token}` },
  });

const updateTaskApi = (
  id: string,
  updates: Partial<{ title: string; completed: boolean; quadrantId: string }>,
  token: string
): Promise<AxiosResponse<TaskResponse>> =>
  axios.put<TaskResponse>(`${API_URL}/tasks/${id}`, updates, {
    headers: { Authorization: `Bearer ${token}` },
  });

const deleteTaskApi = (id: string, token: string): Promise<AxiosResponse<void>> =>
  axios.delete<void>(`${API_URL}/tasks/${id}`, {
    headers: { Authorization: `Bearer ${token}` },
  });

function* handleFetchTasks(): SagaIterator {
  try {
    const token: string | null = yield select((state: RootState) => state.auth.token);

    if (!token) {
      throw new Error("Authentication token is missing.");
    }

    const response: AxiosResponse<TaskResponse[]> = yield call(fetchTasksApi, token);
    yield put(fetchTasksSuccess(response.data));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Failed to fetch tasks.";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Failed to fetch tasks.";
    }

    yield put(fetchTasksFailure(errorMessage));
  }
}

function* handleCreateTask(action: PayloadAction<{ title: string; quadrantId: string }>): SagaIterator {
  try {
    const { title, quadrantId } = action.payload;
    const token: string | null = yield select((state: RootState) => state.auth.token);

    if (!token) {
      throw new Error("Authentication token is missing.");
    }

    const response: AxiosResponse<TaskResponse> = yield call(createTaskApi, { title, quadrantId }, token);
    yield put(createTaskSuccess(response.data));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Failed to create task.";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Failed to create task.";
    }

    yield put(createTaskFailure(errorMessage));
  }
}

function* handleUpdateTask(action: PayloadAction<{ id: string; updates: Partial<TaskResponse> }>): SagaIterator {
  try {
    const { id, updates } = action.payload;
    const token: string | null = yield select((state: RootState) => state.auth.token);

    if (!token) {
      throw new Error("Authentication token is missing.");
    }

    const response: AxiosResponse<TaskResponse> = yield call(updateTaskApi, id, updates, token);
    yield put(updateTaskSuccess(response.data));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Failed to update task.";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Failed to update task.";
    }

    yield put(updateTaskFailure(errorMessage));
  }
}

function* handleDeleteTask(action: PayloadAction<string>): SagaIterator {
  try {
    const id = action.payload;
    const token: string | null = yield select((state: RootState) => state.auth.token);

    if (!token) {
      throw new Error("Authentication token is missing.");
    }

    yield call(deleteTaskApi, id, token);
    yield put(deleteTaskSuccess(id));
  } catch (error: unknown) {
    let errorMessage: string;

    if (axios.isAxiosError(error)) {
      errorMessage = error.response?.data?.error || "Failed to delete task.";
    } else if (error instanceof Error) {
      errorMessage = error.message;
    } else {
      errorMessage = "Failed to delete task.";
    }

    yield put(deleteTaskFailure(errorMessage));
  }
}

function* watchFetchTasks(): SagaIterator {
  yield takeLatest(fetchTasksRequest.type, handleFetchTasks);
}

function* watchCreateTask(): SagaIterator {
  yield takeLatest(createTaskRequest.type, handleCreateTask);
}

function* watchUpdateTask(): SagaIterator {
  yield takeLatest(updateTaskRequest.type, handleUpdateTask);
}

function* watchDeleteTask(): SagaIterator {
  yield takeLatest(deleteTaskRequest.type, handleDeleteTask);
}

export default function* taskSagas(): SagaIterator {
  yield all([
    fork(watchFetchTasks),
    fork(watchCreateTask),
    fork(watchUpdateTask),
    fork(watchDeleteTask),
  ]);
}
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

export interface Task {
  id: string;
  title: string;
  completed: boolean;
  quadrantId: string;
}

interface TaskState {
  tasks: Task[];
  loading: boolean;
  error: string | null;
  searchQuery: string;
}

const initialState: TaskState = {
  tasks: [],
  loading: false,
  error: null,
  searchQuery: "",
};

const taskSlice = createSlice({
  name: "tasks",
  initialState,
  reducers: {
    fetchTasksRequest(state) {
      state.loading = true;
      state.error = null;
    },
    fetchTasksSuccess(state, action: PayloadAction<Task[]>) {
      state.loading = false;
      state.tasks = action.payload;
    },
    fetchTasksFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    createTaskRequest(state, _action: PayloadAction<{ title: string; quadrantId: string }>) {
      state.loading = true;
      state.error = null;
    },
    createTaskSuccess(state, action: PayloadAction<Task>) {
      state.loading = false;
      state.tasks.push(action.payload);
    },
    createTaskFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    updateTaskRequest(state, _action: PayloadAction<{ id: string; updates: Partial<Task> }>) {
      state.loading = true;
      state.error = null;
    },
    updateTaskSuccess(state, action: PayloadAction<Task>) {
      state.loading = false;
      const index = state.tasks.findIndex((task) => task.id === action.payload.id);
      if (index !== -1) {
        state.tasks[index] = action.payload;
      }
    },
    updateTaskFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    deleteTaskRequest(state, _action: PayloadAction<string>) {
      state.loading = true;
      state.error = null;
    },
    deleteTaskSuccess(state, action: PayloadAction<string>) {
      state.loading = false;
      state.tasks = state.tasks.filter((task) => task.id !== action.payload);
    },
    deleteTaskFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    clearAllTasks(state) {
      state.tasks = [];
    },
    setSearchQuery(state, action: PayloadAction<string>) {
      state.searchQuery = action.payload;
    },
    toggleTask(state, action: PayloadAction<string>) {
      const task = state.tasks.find((task) => task.id === action.payload);
      if (task) {
        task.completed = !task.completed;
      }
    }
  },
});

export const {
  fetchTasksRequest,
  fetchTasksSuccess,
  fetchTasksFailure,
  createTaskRequest,
  createTaskSuccess,
  createTaskFailure,
  updateTaskRequest,
  updateTaskSuccess,
  updateTaskFailure,
  deleteTaskRequest,
  deleteTaskSuccess,
  deleteTaskFailure,
  clearAllTasks,
  setSearchQuery,
  toggleTask
} = taskSlice.actions;

export default taskSlice.reducer;
// src/redux/slices/authSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface AuthState {
  token: string | null;
  username: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  token: localStorage.getItem("token"),
  username: localStorage.getItem("username"),
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    // Register Actions
    registerRequest(state, _action: PayloadAction<string>) {
      state.loading = true;
      state.error = null;
    },
    registerSuccess(state, action: PayloadAction<{ token: string; username: string }>) {
      state.loading = false;
      state.token = action.payload.token;
      state.username = action.payload.username;
    },
    registerFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },

    loginRequest(state, _action: PayloadAction<string>) {
      state.loading = true;
      state.error = null;
    },
    loginSuccess(state, action: PayloadAction<{ token: string; username: string }>) {
      state.loading = false;
      state.token = action.payload.token;
      state.username = action.payload.username;
    },
    loginFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },

    // Logout Action
    logout(state) {
      state.token = null;
      state.username = null;
    },
  },
});

export const {
  registerRequest,
  registerSuccess,
  registerFailure,
  loginRequest,
  loginSuccess,
  loginFailure,
  logout,
} = authSlice.actions;

export default authSlice.reducer;
import React, { useState, useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { loginRequest } from "@/redux/slices/authSlice";
import { RootState } from "@/redux/store";
import { useNavigate } from "react-router-dom";

const Login: React.FC = () => {
  const [uniqueID, setUniqueID] = useState("");
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const auth = useSelector((state: RootState) => state.auth);

  console.log("auth", auth);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (uniqueID.trim()) {
      dispatch(loginRequest(uniqueID.trim()));
    }
  };

  if (auth.token) {
    navigate("/tasks");
  }

  useEffect(() => {
    if (auth.token) {
      navigate("/tasks");
    }
  })

  return (
    <div className="max-w-md mx-auto mt-10 p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-semibold mb-4">Login</h2>
      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label htmlFor="uniqueID" className="block text-gray-700">
            Unique ID
          </label>
          <input
            type="text"
            id="uniqueID"
            value={uniqueID}
            onChange={(e) => setUniqueID(e.target.value)}
            className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring focus:border-blue-300 text-gray-800"
            required
          />
        </div>
        {auth.error && <p className="text-red-500 mb-4">{auth.error}</p>}
        <button
          type="submit"
          className="w-full py-2 px-4 bg-green-600 text-white rounded-md hover:bg-green-700"
          disabled={auth.loading}
        >
          {auth.loading ? "Logging in..." : "Login"}
        </button>
      </form>
    </div>
  );
};

export default Login;
import { useDispatch } from "react-redux";
import { setSearchQuery } from "@/redux/slices/taskSlice";

const SearchBar: React.FC = () => {
  const dispatch = useDispatch();

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    dispatch(setSearchQuery(e.target.value));
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Search tasks..."
        onChange={handleSearchChange}
        className="w-full px-4 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 text-gray-800"
      />
    </div>
  );
};

export default SearchBar;
import { FC, useState } from "react";

interface TaskFormProps {
  addTask: (title: string) => void;
  cancel: () => void;
}

const TaskForm: FC<TaskFormProps> = ({ addTask, cancel }) => {
  const [newTaskTitle, setNewTaskTitle] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTaskTitle.trim()) {
      addTask(newTaskTitle.trim());
      setNewTaskTitle("");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="flex gap-2">
        <input
          type="text"
          value={newTaskTitle}
          onChange={(e) => setNewTaskTitle(e.target.value)}
          placeholder="Enter task title..."
          className="w-full px-4 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500 text-gray-800"
          autoFocus
        />
        <button
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
        >
          Add
        </button>
        <button
          type="button"
          className="px-4 py-2 bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300"
          onClick={cancel}
        >
          Cancel
        </button>
      </div>
    </form>
  );
};

export default TaskForm;
import { FC } from "react";
import { useDispatch } from "react-redux";
import { toggleTask } from "@/redux/slices/taskSlice";
import { Task } from "@/types/task";

interface TaskItemProps {
  task: Task;
  toggleTask: (id: string, currentStatus: boolean) => void;
  deleteTask: (id: string, currentStatus: boolean) => void;
}

const TaskItem: FC<TaskItemProps> = ({ task }) => {
  const dispatch = useDispatch();

  return (
    <div
      className={`
        ${task.completed ? "bg-green-50 border-green-200" : "bg-white border-gray-200"}
        rounded-lg p-4 transition-all duration-200 hover:shadow-md cursor-pointer border
      `}
    >
      <div className="flex items-center justify-between">
        <span className={`text-gray-800 font-medium ${task.completed ? "text-green-800" : ""}`}>
          {task.title}
        </span>
        <input
          type="checkbox"
          checked={task.completed}
          onChange={() => dispatch(toggleTask(task.id))}
          className="h-5 w-5 rounded-md border-gray-300 text-blue-600 focus:ring-blue-500 shadow-sm focus:ring-2"
        />
      </div>
    </div>
  );
};

export default TaskItem;
import { FC } from "react";
import TaskItem from "./TaskItem";
import { Task } from "@/types/task"

interface TaskListProps {
  tasks: Task[];
  toggleTask: (id: string, currentStatus: boolean) => void;
  deleteTask: (id: string, currentStatus: boolean) => void;
}

const TaskList: FC<TaskListProps> = ({ tasks, toggleTask, deleteTask }) => (
  <div className="space-y-3">
    {tasks.map((task) => (
      <TaskItem key={task.id} task={task} toggleTask={toggleTask} deleteTask={deleteTask} />
    ))}
  </div>
);

export default TaskList;
import React, { useState, useEffect, FormEvent } from "react";
import { useSelector } from "react-redux";
import { useAppDispatch } from "@/redux/store";
import { registerRequest } from "@/redux/slices/authSlice";
import { useNavigate } from "react-router-dom";
import { RootState } from "@/redux/store";

const Register: React.FC = () => {
  const dispatch = useAppDispatch();
  const [uniqueID, setUniqueID] = useState("");
  const navigate = useNavigate();

  const auth = useSelector((state: RootState) => state.auth);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (uniqueID.trim()) {
      dispatch(registerRequest(uniqueID.trim()));
    }
  };

  useEffect(() => {
    if (auth.token) {
      navigate("/tasks");
    }
  })

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={uniqueID}
        onChange={(e) => setUniqueID(e.target.value)}
        placeholder="Enter Unique ID"
        className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring focus:border-blue-300 text-gray-800"
        required
      />
      <button type="submit">Register</button>
    </form>
  );
};

export default Register;
import React from "react";
import { useDispatch } from "react-redux";
import { logout } from "@/redux/slices/authSlice";
import { useNavigate } from "react-router-dom";

const LogoutButton: React.FC = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const handleLogout = () => {
    localStorage.removeItem("token");
    localStorage.removeItem("username");

    dispatch(logout());

    navigate("/login");
  };

  return (
    <button
      onClick={handleLogout}
      className="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700"
    >
      Logout
    </button>
  );
};

export default LogoutButton;
// src/components/quadrants/Quadrant.tsx
import React, { useState } from "react";
import { useSelector, useDispatch } from "react-redux";
import { RootState } from "@/redux/store";
import TaskList from "@/components/task/TaskList";
import TaskForm from "@/components/task/TaskForm";
import QuadrantHeader from "./QuadrantHeader";
import {
  createTaskRequest,
  updateTaskRequest,
  deleteTaskRequest,
  clearAllTasks,
  setSearchQuery,
} from "@/redux/slices/taskSlice";

interface QuadrantProps {
  quadrantId: string;
  title: string;
}

const Quadrant: React.FC<QuadrantProps> = ({ quadrantId, title }) => {
  const tasks = useSelector((state: RootState) => state.tasks.tasks);
  const searchQuery = useSelector((state: RootState) => state.tasks.searchQuery);
  const dispatch = useDispatch();
  const [isAdding, setIsAdding] = useState(false);

  const toggleTask = (id: string, currentStatus: boolean) => {
    dispatch(updateTaskRequest({ id, updates: { completed: !currentStatus } }));
  };

  const deleteTask = (id: string) => {
    dispatch(deleteTaskRequest(id));
  };

  const addTask = (title: string) => {
    dispatch(createTaskRequest({ title, quadrantId }));
    setIsAdding(false);
  };

  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    dispatch(setSearchQuery(e.target.value));
  };

  const filteredTasks = tasks.filter(
    (task) =>
      task.title.toLowerCase().includes(searchQuery.toLowerCase()) &&
      task.quadrantId === quadrantId
  );

  return (
    <div className="bg-gray-100 p-6 rounded-xl shadow-lg h-[400px] flex flex-col">
      <QuadrantHeader title={title} />

      {/* Search Bar */}
      <input
        type="text"
        value={searchQuery}
        onChange={handleSearch}
        placeholder="Search tasks..."
        className="mb-4 p-2 border rounded"
      />

      <div className="flex-1 flex flex-col min-h-0">
        <div className="flex-1 overflow-y-auto pr-2">
          <TaskList
            tasks={filteredTasks}
            toggleTask={toggleTask}
            deleteTask={deleteTask}
          />
        </div>

        <div className="pt-4 mt-auto">
          {isAdding ? (
            <TaskForm addTask={addTask} cancel={() => setIsAdding(false)} />
          ) : (
            <button
              onClick={() => setIsAdding(true)}
              className="w-full py-2 border-dashed border-2 rounded-lg text-gray-600 hover:text-gray-800 hover:border-gray-400"
            >
              + Add Task
            </button>
          )}
        </div>
      </div>

      {/* Clear All Tasks Button */}
      <button
        onClick={() => dispatch(clearAllTasks())}
        className="mt-4 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
      >
        Clear All Tasks
      </button>
    </div>
  );
};

export default Quadrant;
import React from "react";
import { Navigate } from "react-router-dom";
import { useSelector } from "react-redux";
import { RootState } from "@/redux/store";

interface PrivateRouteProps {
  children: JSX.Element;
}

const PrivateRoute: React.FC<PrivateRouteProps> = ({ children }) => {
  const auth = useSelector((state: RootState) => state.auth);
  return auth.token ? children : <Navigate to="/login" />;
};

export default PrivateRoute;
import { FC } from "react";
import { useSelector, useDispatch } from "react-redux";
import { RootState } from "@/redux/store";
import { clearActiveTasks, deleteActiveTasks, toggleSelectedTasks } from "@/redux/slices/taskSlice";

const GlobalContextMenu: FC = () => {
  const dispatch = useDispatch();
  const activeTaskCount = useSelector((state: RootState) => state.tasks.activeTasks.length);

  if (activeTaskCount === 0) return null;

  return (
    <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-white text-gray-800 shadow-lg rounded-md border p-4 flex gap-4 justify-center items-center">
      <span>{activeTaskCount} task(s) selected</span>

      <button
        onClick={() => dispatch(clearActiveTasks())}
        className="px-4 py-2 bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300"
      >
        Clear Selection
      </button>
      <button
        onClick={() => dispatch(toggleSelectedTasks())}
        className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
      >
        Toggle Selected
      </button>
      <button
        onClick={() => dispatch(deleteActiveTasks())}
        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
      >
        Delete Selected
      </button>
    </div>
  );
};

export default GlobalContextMenu;
import { FC } from "react";

interface QuadrantHeaderProps {
  title: string;
}

const QuadrantHeader: FC<QuadrantHeaderProps> = ({ title }) => (
  <h2 className="text-xl font-semibold text-gray-800 mb-4">{title}</h2>
);

export default QuadrantHeader;
// src/components/quadrants/QuadrantContainer.tsx
import { useEffect } from "react";
import Quadrant from "./Quadrant";
import SearchBar from "@/components/search";
import { useDispatch } from "react-redux";
import { clearAllTasks, fetchTasksRequest } from "@/redux/slices/taskSlice";
import LogoutButton from "@/components/LogoutButton";

const QuadrantContainer = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchTasksRequest());
  }, [dispatch]);

  return (
    <div className="p-8 w-full">
      <div className="flex justify-between items-center mb-4">
        <SearchBar />
        <LogoutButton />
      </div>
      <div className="flex justify-end">
        <button
          onClick={() => dispatch(clearAllTasks())}
          className="px-4 py-2 my-8 bg-red-500 text-white rounded-lg hover:bg-red-600"
        >
          Clear All
        </button>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 w-full">
        <Quadrant title="Urgent & Important" quadrantId="urgent-important" />
        <Quadrant title="Not Urgent & Important" quadrantId="not-urgent-important" />
        <Quadrant title="Urgent & Not Important" quadrantId="urgent-not-important" />
        <Quadrant title="Not Urgent & Not Important" quadrantId="not-urgent-not-important" />
      </div>
    </div>
  );
};

export default QuadrantContainer;
