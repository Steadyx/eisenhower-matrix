import express, { Application, Request, Response } from 'express';
import { errorHandler } from "@middleware/errorHandler";
import cors from 'cors';
import * as dotenv from "dotenv";
import mongoose from 'mongoose';
import taskRoutes from '@routes/taskRoutes';
import authRoutes from '@routes/authRoutes';

// Load environment variables
dotenv.config();

// Initialize Express app
const app: Application = express();
const PORT = process.env.PORT || 4000;


const corsOptions = {
  origin: 'http://localhost:5173',
  credentials: true,
};

// Middleware
app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Connect to MongoDB
const MONGO_URI = process.env.MONGO_URI || 'mongodb://localhost:27017/eisenhower_dev';
mongoose
  .connect(MONGO_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch((error) => console.error('Error connecting to MongoDB:', error));

app.get('/', (_req: Request, res: Response) => {
  res.send('Welcome to the Eisenhower Matrix API');
});


app.use('/auth', authRoutes);
app.use('/tasks', taskRoutes);

app.use(errorHandler);

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
import crypto from 'crypto';
import bcrypt from 'bcrypt';

/**
 * Generates a cryptographically secure unique ID.
 * @returns {string} A 128-bit (16-byte) hexadecimal string.
 */
export const generateUniqueID = (): string => {
  return crypto.randomBytes(16).toString('hex'); // 128-bit ID represented in hex
};

/**
 * Generates a username based on the provided unique ID.
 * @param {string} id - The unique ID to base the username on.
 * @returns {string} A formatted username string.
 */
export const generateUsername = (id: string): string => {
  // Ensure the ID is long enough
  if (id.length < 8) {
    throw new Error('ID is too short to generate a username.');
  }
  return `user_${id.slice(0, 8)}`; // Example: user_a1b2c3d4
};

/**
 * Hashes the provided unique ID using bcrypt.
 * @param {string} id - The unique ID to hash.
 * @returns {Promise<string>} The hashed ID.
 */
export const hashID = async (id: string): Promise<string> => {
  const saltRounds = 12; // Adjust salt rounds as needed (higher is more secure but slower)
  try {
    const salt = await bcrypt.genSalt(saltRounds);
    const hashed = await bcrypt.hash(id, salt);
    return hashed;
  } catch (error) {
    throw new Error('Error hashing the unique ID.');
  }
};

/**
 * Compares a plain unique ID with its hashed version.
 * @param {string} id - The plain unique ID provided by the user.
 * @param {string} hash - The hashed unique ID stored in the database.
 * @returns {Promise<boolean>} Whether the IDs match.
 */
export const compareID = async (id: string, hash: string): Promise<boolean> => {
  try {
    const isMatch = await bcrypt.compare(id, hash);
    return isMatch;
  } catch (error) {
    throw new Error('Error comparing the unique ID.');
  }
};
import { Router } from 'express';
import { register, login } from '@controllers/authController';

const router = Router();

router.post('/register', register);
router.post('/login', login);

export default router;
import { Router } from 'express';
import {
  getTasks,
  addTask,
  updateTask,
  deleteTask,
} from '@controllers/taskController';
import { authenticate } from '@middleware/authenticate';

const router = Router();

// Apply authentication middleware to all task routes
router.use(authenticate);

// Define your routes...
router.get('/', getTasks);
router.post('/', addTask);
router.put('/:id', updateTask);
router.delete('/:id', deleteTask);

export default router;
import mongoose, { Document, Schema } from "mongoose";

export interface ITask extends Document {
  title: string;
  completed: boolean;
  quadrantId: string;
  createdAt: Date;
  updatedAt: Date;
}

const TaskSchema: Schema = new Schema<ITask>(
  {
    title: {
      type: String,
      required: [true, "Title is required"],
      trim: true,
    },
    completed: {
      type: Boolean,
      default: false,
    },
    quadrantId: {
      type: String,
      required: [true, "Quadrant ID is required"],
      enum: [
        "urgent-important",
        "not-urgent-important",
        "urgent-not-important",
        "not-urgent-not-important",
      ],
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<ITask>("Task", TaskSchema);
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  username: string;
  password: string;
  hashedID: string;
  comparePassword: (password: string) => Promise<boolean>;
}

const UserSchema: Schema = new Schema<IUser>(
  {
    username: {
      type: String,
      required: [true, 'Username is required'],
      unique: true,
      trim: true,
    },
    hashedID: {
      type: String,
      required: [true, 'Hashed ID is required'],
    },
    password: {
      type: String,
    },
  },
  {
    timestamps: true,
  }
);

UserSchema.pre<IUser>('save', async function(next) {
  if (!this.isModified('password')) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    return next();
  } catch (err) {
    if (err instanceof Error) {
      return next(err);
    }
  }
});

UserSchema.methods.comparePassword = async function(password: string) {
  return bcrypt.compare(password, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);
import dotenv from "dotenv";
dotenv.config();

const requiredEnvVars = ["MONGO_URI", "JWT_SECRET"];

requiredEnvVars.forEach((key) => {
  if (!process.env[key]) {
    throw new Error(`Missing required environment variable: ${key}`);
  }
});
import User, { IUser } from '@models/User';
import { generateUniqueID, generateUsername, hashID, compareID } from '../utils';
import jwt from 'jsonwebtoken';

/**
 * Finds a user by their uniqueID.
 * @param uniqueID - The unique identifier provided by the user.
 * @returns The user if found, otherwise null.
 */
export const findUserByUniqueID = async (uniqueID: string): Promise<IUser | null> => {
  return await User.findOne({ uniqueID });
};

/**
 * Registers a new user with username, hashedID, and uniqueID.
 * @param username - Generated username.
 * @param hashedID - Hashed version of uniqueID.
 * @param uniqueID - The unique identifier provided by the user.
 * @returns The newly created user.
 * @throws Error if username or uniqueID already exists.
 */
export const register = async (
  username: string,
  hashedID: string,
  uniqueID: string
): Promise<IUser> => {
  const existingUser = await User.findOne({ username });
  if (existingUser) {
    throw new Error('Username already exists');
  }

  const existingUniqueID = await findUserByUniqueID(uniqueID);
  if (existingUniqueID) {
    throw new Error('Unique ID already in use');
  }

  const user = new User({ username, hashedID, uniqueID });
  await user.save();
  return user;
};

/**
 * Authenticates a user by their uniqueID.
 * @param uniqueID - The unique identifier provided by the user.
 * @returns The authenticated user if credentials are valid, otherwise null.
 */
export const authenticate = async (uniqueID: string): Promise<IUser | null> => {
  const user = await User.findOne({ uniqueID });

  if (!user) return null;

  const isMatch = await compareID(uniqueID, user.hashedID);
  return isMatch ? user : null;
};

/**
 * Generates a JWT token for a user.
 * @param user - The user for whom to generate the token.
 * @returns A signed JWT token.
 */
export const generateJWT = (user: IUser): string => {
  const payload = { id: user._id, username: user.username };
  const secret = process.env.JWT_SECRET || 'your_jwt_secret';
  const options = { expiresIn: '1h' };
  return jwt.sign(payload, secret, options);
};

export { generateUniqueID, generateUsername, hashID, compareID };
import Task from "@models/Task";

export const getAllTasks = async () => {
  return Task.find();
};

export const createTask = async (title: string, quadrantId: string) => {
  const task = new Task({ title, quadrantId });
  return task.save();
};

export const updateTask = async (id: string, updates: object) => {
  return Task.findByIdAndUpdate(id, updates, { new: true });
};

export const deleteTask = async (id: string) => {
  return Task.findByIdAndDelete(id);
};
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'default_secret';

interface JwtPayload {
  id: string;
  username: string;
  iat: number;
  exp: number;
}

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    username: string;
  };
}

export const authenticate = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Authentication token missing or invalid' });
    return;
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;
    req.user = { id: decoded.id, username: decoded.username };
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid or expired token' });
  }
};
import { Request, Response, NextFunction } from "express";
import mongoose from 'mongoose';

export const errorHandler = (
  err: any,
  _req: Request,
  res: Response,
  _next: NextFunction
): void => {
  console.error(err.stack);

  if (res.headersSent) {
    return;
  }

  // Mongoose validation error
  if (err instanceof mongoose.Error.ValidationError) {
    res.status(400).json({ error: err.message });
    return;
  }

  // Mongoose duplicate key error
  if (err.code && err.code === 11000) {
    res.status(409).json({ error: 'Duplicate key error', details: err.keyValue });
    return;
  }

  // JWT authentication error
  if (err.name === 'JsonWebTokenError') {
    res.status(401).json({ error: 'Invalid token' });
    return;
  }

  // Default to 500 server error
  res.status(err.status || 500).json({
    message: err.message || "Internal Server Error",
  });
};
import { RequestHandler } from 'express';
import * as authService from '@services/authService';

interface RegisterBody {
  uniqueID: string;
}

export const register: RequestHandler<{}, any, RegisterBody> = async (req, res, _next) => {
  try {
    const { uniqueID } = req.body;

    if (!uniqueID) {
      res.status(400).json({ error: 'Unique ID is required' });
      return;
    }

    const existingUser = await authService.findUserByUniqueID(uniqueID);
    if (existingUser) {
      res.status(409).json({ error: 'Unique ID already in use' });
      return;
    }

    const username = authService.generateUsername(uniqueID);
    const hashedID = await authService.hashID(uniqueID);
    const user = await authService.register(username, hashedID, uniqueID);

    const token = authService.generateJWT(user);

    res.status(201).json({
      message: 'User registered successfully',
      token,
      username: user.username,
    });
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const login: RequestHandler<{}, any, RegisterBody> = async (req, res, _next) => {
  try {
    const { uniqueID } = req.body;

    if (!uniqueID) {
      res.status(400).json({ error: 'Unique ID is required' });
      return;
    }

    const user = await authService.authenticate(uniqueID);

    if (!user) {
      res.status(401).json({ error: 'Invalid Unique ID' });
      return;
    }

    const token = authService.generateJWT(user);

    res.status(200).json({ token, username: user.username });
  } catch (error) {
    if (error instanceof Error) {
      res.status(401).json({ error: error.message });
      return;
    }
    res.status(500).json({ error: 'Internal server error' });
  }
};
import { Request, Response } from "express";
import * as taskService from "@services/taskService";

export const getTasks = async (_req: Request, res: Response) => {
  try {
    const tasks = await taskService.getAllTasks();
    res.status(200).json(tasks);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
};

export const addTask = async (req: Request, res: Response) => {
  try {
    const { title, quadrantId } = req.body;
    const task = await taskService.createTask(title, quadrantId);
    res.status(201).json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
};

export const updateTask = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    const task = await taskService.updateTask(id, updates);
    res.status(200).json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
};


export const deleteTask = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const task = await taskService.deleteTask(id);
    res.status(200).json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
};
